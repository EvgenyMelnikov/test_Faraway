# test_Faraway

Количество часов ~ 12

Продумывание архитектуры - 6ч
Написание систем - 4ч
Визуальная составляющая 2ч

В качестве базовой архитектуры управления зависимостями игровой сцены выбран ZenJect. Этот инструмент идеально подходит для быстрого прототипирования и уменьшает количество кода (не нужен блок связывания компонентов друг с другом). На его базе сделана система игрового мира.

Игровой мир представляет из себя набор контроллеров, отвечающих за общие аспекты поведения. Например, движение мира относительно персонажа и управление жизненным циклом монеток.
Существует общий контейнер игровых сущностей IWorld. Создание и удаление этих сущностей происходи через контейнер. Так же контейнер хранит и предоставляет поиск сущностей по типам.
Системы игрового мира должны существовать в одном экземпляре, поэтому ZenJect идеально подходит для их связывания. Для базовых механик достаточно инъекций в конструкторы контроллеров. Для более сложных взаимодействий можно использовать подход через команды.
Для упрощения использован только SceneContext, но при усложнении и правильном разделении контекстов можно реализовать грамотное управление ресурсами при загрузке/выгрузке уровней.
Любая сущность унаследованная от Actor может быть использована в IWorld. На примере LocationController видно, что мы получаем все сущности на уровне и манипулируем ими. Реализован не оптимальный, но быстрый подход поиска по типам каждый кадр. В условиях ограничения времени этот подход оправдан, но требует оптимизации для выпуска в прод. Как минимум распределение на этапе добавления актера будет выгодней в долгосрочной перспективе.

Для организации поведения персонажа была разработана компонентная система.
Есть Entity. Это контейнер для компонентов.
IComponent используется как хранилище данных. В частности SpeedComponent хранит скорость персонажа.
ISystem описывает часть поведения персонажа. Для изменения поведения достаточно добавить/убрать/заменить систему. У систем есть минимальный жизненный цикл, для более точного управления. Системы могут заменяться в любое время и используют компоненты как настройки.

Система требует тщательной доработки, но уже демонстрирует гибкость разработки с ее использованием.
Схожесть названий с ECS выбрана не случайно, так как в основу лег основной принцип ECS (разделения данных и исполняемого когда) но в сильно упрощенном виде. Именно из-за избыточности подход ECS для данной задачи он и не был выбран. Для демонстрирования моих навыков в ECS могу привести мое раннее тестовое задание.
https://github.com/evgeniyMelnikovY/ECSTest
